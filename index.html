<!DOCTYPE html><html lang="pt-br"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Workflow with Stylus</title><meta name="description" content=""><meta name="keywords" content=""><link rel="stylesheet" href="css/styles.css"></head><body><div class="container"><header class="header heading"><img class="image" src="img/gulp-stylus.png"><h1 class="title">Workflow simples, porém muito eficiente</h1><h2 class="description">Automatizando seu workflow front-end com Gulp modularizado e Stylus</h2></header><section class="box"><div class="description"><p class="text">Salve salve peoples, tudo na paz?</p><p class="text">Não sei apenas eu ou mais alguém já passou por isso. A cada novo projeto, ter que refazer o workflow, com task runner, pré-processador CSS, template engine, frameworks, mi-mi-mi.</p><p class="text">Fui um pouquinho tapado em demorar pra ter um repositório como base de workflow! Eis que surgiu esse workflow simples, porém muito eficiente!</p><p class="text">Fiquei tão encanado com isso, que resolvi criar um workflow. Porém, uma coisa acabou me tirando o sono, literalmente. As tarefas do Gulp, muitas e muitas linhas no gulpfile.js.</p><p class="text">Sobre as tarefas do Gulp, tá lá no final do artigo. Mas leia tudinho, sem pressa! =D</p><p class="text">Para entendermos melhor como ficou tudo, vamos começar pela estrutura de arquivos:</p><div class="workflow-estrutura"><div class="workflow-image pull-left"><img class="image" src="img/workflow-estrutura.png"></div><div class="workflow-list pull-left cf"><ul><li><span class="arquivo-code">_public/</span><p>Nessa pasta ficam os arquivos compilados, após o desenvolvimento. Vísivel no navegador; pronto para ser enviado para homologação. Separados pelas pastas&#32;<span class="arquivo-code">css / img / js / _includes</span>.</p></li><li><span class="arquivo-code">_source/</span><p>Aqui é onde a magia realmente acontece! rs'</p><p>Nosso ambiente de produção. Onde utilizo o&#32;<span class="arquivo-code">Pug</span>&#32;como template engine;&#32;<span class="arquivo-code">Stylus</span>&#32;como pré-processador CSS. Tentei implementar RSCSS & ITCSS como metodologias.
&#32;Além da combinação&#32;<span class="arquivo-code">Jeet + Nib + Rupture</span>&#32;como grid system, mixins para&#32;<span class="arquivo-code">Stylus</span>&#32;e media queries, respectivamente.</p></li><li><span class="arquivo-code">tasks</span><p>Meu bebê do s2! Nessa pasta possui um&#32;<span class="arquivo-code">arquivo.js</span>&#32;para cada tarefa do&#32;<span class="arquivo-code">Gulp</span>.</p><p>No decorrer desse artigo irei entrar em mais detalhes de como modularizei as tarefas do&#32;<span class="arquivo-code">Gulp</span>&#32;.</p></li></ul></div></div><div class="sub-description heading cf"><h3 class="sub-description">RSCSS e ITCSS? Why??</h3><p class="text">Sempre busco formas de padronizar minhas declarações CSS e uma arquitetura boa, de fácil manutenção. Li um pouco sobre&#32;<span class="arquivo-code">BEM</span>&#32;, porém não gostei. Achei a nomenclatura das classes sugerida muito extensa e em determinados projetos completos poderia ser confuso para manutenção. Visto isso, encontrei dois artigos do&#32;<a class="link" href="https://twitter.com/willian_justen" target="_blank">Willian Justen</a>&#32;sobre ambas as metodologias,&#32;<a class="link" href="http://willianjusten.com.br/falando-sobre-rscss/" target="_blank">RSCSS</a>&#32;e&#32;<a class="link" href="http://willianjusten.com.br/organizando-seu-css-com-itcss/" target="_blank">ITCSS</a>.</p><p class="text">Ele explicou com uma didática tão leve que foi de longe um dos melhores artigos sobre arquiteturas CSS. Já tinha optado por ITCSS em outras leituras, porém esse artigo em específico concretizei minha decisão.</p><p class="text">Aqui, não irei entrar em detalhes de como funciona o ITCSS ou RSCSS. Para isso, passa lá no link do artigo que o Willian Justen compartilhou conosco, que praticamente é uma documentação em pt-BR! =)</p><p class="text">Digamos que você vá desenvolver um projeto complexo, de um portal para uma grande empresa/agência, um portal estático ou dinâmico, por exemplo, que irá ter 20 páginas ou mais. No momento em que formos definir a arquitetura CSS para o desenvolvimento vai começar a complicar. Visto isso, o&#32;<span class="arquivo-code">ITCSS</span>&#32;surgiu, para organizar nosso CSS de forma escalável e de fácil manutenção.</p><p class="text dialog">Beleza, tio! Definimos a arquitetura. Mas e como iremos nomear as classes? Que tipo de padrão podemos utilizar pra isso?</p><p class="text">Entra em cena o&#32;<span class="arquivo-code">RSCSS</span>&#32;!!!!</p><p class="text">Quanto maior o projeto, maior vai ser o número de linhas de declarações CSS. E, acredite, se não houver um padrão, VAI DAR BO! Quem nunca se perguntou pra que classe X ou Y serve, pra que repetiu Z ou A, etc, etc.</p><p class="text">Nisso, o&#32;<span class="arquivo-code">RSCSS</span>&#32;nos dá ideias claras de como nomear classes sem medo de nos perdemos futuramente. Facilitando assim que o processo de desenvolvimento do nosso CSS seja rentável para qualquer projeto front-end.</p><p class="text">Juntar as duas metodologias foi praticamente um casamento perfeito! Parece que as duas são feitas uma para a outra! =D</p><p class="text">Mais um ponto a favor do&#32;<span class="arquivo-code">RSCSS</span>&#32;é que podemos utilizar essa metodologia junto com&#32;<span class="arquivo-code">Atomic Design</span>. Já temos um padrão de atoms, molecules e organisms nas classes, porém podemos facilmente integrar as duas metodologias. E, podemos ir além, não parar nos atoms.</p><p class="text">Baseando-se nas aulas do curso&#32;<a class="link" href="https://github.com/Webschool-io/be-mean-instagram" target="_blank">Be MEAN</a>&#32;do&#32;<a class="link" href="https://twitter.com/osuissa" target="_blank">Suissa</a>, onde ele nos ensina a utilizar Quarks, Hadrons, etc no back-end.&#32;<a class="link" href="https://github.com/Webschool-io/Node-Atomic-Design-Modelo-Padrao" target="_blank">Física louca</a>, sem dó, porém, muito efetiva. E sim, podemos basearmos nisso e utilizar em nosso front-end!</p></div><div class="sub-description heading"><h3 class="sub-description">E aquela pastinha _includes ali, pra que serve?</h3><p class="text">No&#32;<span class="arquivo-code">Pug (Jade)</span>&#32;podemos utilizar includes. Digamos que você tenha um projeto web complexo, com front e back-end. No front-end, 90% das páginas irão utilizar o mesmo menu, mesmo header, mesmo footer. Apenas o conteúdo de cada página irá mudar. Pra que repetir esse código em todas as páginas ou porque não usar&#32;<span class="arquivo-code">extend template</span><span class="arquivo-code">&#32;block content</span>?</p><p class="text">Simples, tornando a integração do back-end mais fácil, sem complicações, dinâmico. Com um simples include, podemos trabalhar no back-end para trocar o include X de poucas linhas em certos eventos. Já o extend teria um bloco maior, com mais linhas. O carregamento seria um pouco mais demorado que o include, mesmo não sendo notado a olho nú, mas seria.</p><p class="text">Visando a performance, fácil integração com back-end e fácil manutenção, a escolha para projetos complexos é ir de&#32;<span class="arquivo-code">include</span>. Uma escolha pessoal, não é regra, não é padrão!</p></div><div class="sub-description heading"><h3 class="sub-description">Gulp, deixando-o mais bonitinho ainda =)</h3><p class="text">A justificava para modularizar as tarefas&#32;<span class="arquivo-code">Gulp</span>&#32;foi simples:</p><p class="text dialog">Se eu posso componetizar/modularizar meu CSS; com aplicações AngularJS; com aplicações PHP (MVC); com aplicações NodeJS s2; porque não posso fazer isso com as minhas tarefas do Gulp?</p><p class="text">Você, dev front-end que conhece e trabalha com Gulp, quantas vezes você parou pra pensar:<span class="dialog">&#32;Poxa meu, quantas linhas eu não tenho em um simples gulpfile.js? Já passaram 110 linhas, que saco! Como posso melhorar isso? Não posso modularizar/componetizar igual fazemos com CSS?</span></p><p class="text">Fiquei extremamente estressado em ver aquele horror. Então, mais noites com poucas horas de sono se foram, rsrs'.</p><p class="text">Encontrei inúmeros tutoriais a respeito, porém a maioria utilizava o Browserify ou Webpack. Lendo um pouco sobre cada um deles, acabei chegando a conclusão de que eles são indicados para projetos mais complexos. Um site, portal de notícias, portfolio, hotsite não vi necessidade de implementá-los. Seria um desperdício de tecnologia!</p><p class="text">Depois de tantas pesquisas, conheci a dependência&#32;<a class="link" href="https://www.npmjs.com/package/gulp-load-plugins" target="_blank">gulp-load-plugins</a>&#32;encontrando no blog da editora&#32;<a class="link" href="https://www.packtpub.com/books/content/blogs" target="_blank">Packt Publishing</a>&#32;um EXCELENTE artigo escrito por Brian Hough: &#32;<a class="dialog link" href="https://www.packtpub.com/books/content/how-to-simplify-your-development-workflow-with-gulp" target="_blank">How to Simplify Your Development Workflow with Gulp</a>&#32;.</p><p class="text">Após todas as tarefas em arquivos separados, Gulp modularizado, belezinha, o arquivo&#32;<span class="arquivo-code">gulpfile.js</span>&#32;ficou dessa forma:</p><img src="img/gulpfile-final.png"><p class="text">Com essa dependência, conseguimos criar um&#32;<span class="arquivo-code">arquivo.js</span>&#32;para cada tarefa e no&#32;<span class="arquivo-code">gulpfile.js</span>&#32;chamar cada tarefa utilizando o&#32;<span class="arquivo-code">require</span>.</p><p class="text">Enquanto isso, consumimos o&#32;<span class="arquivo-code">config.json</span>&#32;com os caminhos dos diretórios de cada CSS, Imagem, JS, HTML, seja do ambiente de desenvolvimento (source) ou o destino (_public).</p><p class="text">Abaixo, você visualiza exemplo de duas tarefas, o&#32;<span class="arquivo-code">browser-sync.js</span>&#32;e&#32;<span class="arquivo-code">stylus.js</span>, onde utilizar um simples&#32;<span class="arquivo-code">module.exports</span>&#32; para exportamos uma função que já recebe como parâmetro, o próprio&#32;<span class="arquivo-code">gulp</span>&#32;além do&#32;<span class="arquivo-code">config.json</span>&#32; e a dependência responsável por carregar todas as demais dependências do&#32;<span class="arquivo-code">Gulp (plugins)</span>.</p><img src="img/browser-sync-stylus.png"><p class="text">Trabalhando dessa forma, caso surga alguma nova dependência e por consequência uma nova tarefa, basta criarmos um arquivo novo, chamarmos com o require e incluirmos nas demais tarefas, caso seja necessário. Fácil manutenção, fácil atualização, fácil integração!</p></div><div class="sub-description heading"><h3 class="sub-description">Concluindo..</h3><p class="text">Que artigo longo, rapaz! rs'</p><p class="text">A minha ideia aqui foi compartilhar um pouco de um workflow simples, porém eficiente atende às minhas necessidades atuais em front-end. Sei que tenho muito a melhorar, adicionar mais algumas coisinhas pra melhorar ainda mais esse workflow. Mas por enquanto, atende às minhas necessidades muito bem.</p><p class="text">Ainda é um dos primeiros artigos que escrevo, então sorry se não me expressei tão bem em alguns pontos. Se alguém quiser utilizar, fique a vontade, o código está todo em meu&#32;<a class="link" href="https://github.com/ednilsonamaral/workflow" target="_blank">GitHub</a>. Peço apenas que dê os devidos créditos! =p</p><p class="text">Caso tenha alguma dúvida, sugestão, reclamação, please, entre em contato comigo, através de um simples comentário ou criando uma issue nesse&#32;<a class="link" href="https://github.com/ednilsonamaral/workflow" target="_blank">repositório</a>. Se gostou ou não, compartilhe com seus amigos front-end! =p</p><p class="text">É isso aí pessoal, vaaleu, até mais! =D</p></div><div class="sub-description heading"><h3 class="sub-description">Referências</h3><ul><li><a class="link" href="http://willianjusten.com.br/falando-sobre-rscss/" target="_blank">Falando sobre RSCSS</a></li><li><a class="link" href="http://willianjusten.com.br/organizando-seu-css-com-itcss/" target="_blank">Organizando seu CSS com ITCSS</a></li><li><a class="link" href="https://www.xfive.co/blog/itcss-scalable-maintainable-css-architecture/" target="_blank">ITCSS: SCALABLE AND MAINTAINABLE CSS ARCHITECTURE</a></li><li><a class="link" href="http://www.creativebloq.com/web-design/manage-large-css-projects-itcss-101517528" target="_blank">Manage large CSS projects with ITCSS</a></li><li><a class="link" href="http://lucasmaiaesilva.com.br/grids-sem%C3%A2nticos-com-jeet/" target="_blank">Grids Semânticos com Jeet</a></li><li><a class="link" href="http://codepen.io/suissa/pen/RNWeaE" target="_blank">Jeet 5 - Mobile First (Stylus)</a></li><li><a class="link" href="https://www.packtpub.com/books/content/how-to-simplify-your-development-workflow-with-gulp" target="_blank">How to Simplify Your Development Workflow with Gulp</a></li><li><a class="link" href="https://davidwalsh.name/stylus-rem" target="_blank">Stylus PX to REM Mixin</a></li></ul></div></div></section></div><footer class="footer"><p class="text">by Ednilson Amaral</p></footer></body></html>