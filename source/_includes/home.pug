div.description
    p.text Salve salve peoples, tudo na paz?

    p.text Não sei apenas eu ou mais alguém já passou por isso. A cada novo projeto, ter que refazer o workflow, com task runner, pré-processador CSS, template engine, frameworks, mi-mi-mi.

    p.text Fui um pouquinho tapado em demorar pra ter um repositório como base de workflow! Eis que surgiu esse workflow simples, porém muito eficiente!

    p.text Fiquei tão encanado com isso, que resolvi criar um workflow. Porém, uma coisa acabou me tirando o sono, literalmente. As tarefas do Gulp, muitas e muitas linhas no gulpfile.js.

    p.text Sobre as tarefas do Gulp, tá lá no final do artigo. Mas leia tudinho, sem pressa! =D

    p.text Para entendermos melhor como ficou tudo, vamos começar pela estrutura de arquivos:

    div.workflow-estrutura
        div.workflow-image.pull-left
            img.image(src='img/workflow-estrutura.png')
        div.workflow-list.pull-left.cf
            ul
                li
                    span.arquivo-code _public/

                    p
                        | Nessa pasta ficam os arquivos compilados, após o desenvolvimento. Vísivel no navegador; pronto para ser enviado para homologação. Separados pelas pastas&#32;
                        span.arquivo-code css / img / js / _includes
                        | .


                li
                    span.arquivo-code _source/
                    p Aqui é onde a magia realmente acontece! rs'

                    p
                        | Nosso ambiente de produção. Onde utilizo o&#32;
                        span.arquivo-code Pug
                        | &#32;como template engine;&#32;
                        span.arquivo-code Stylus
                        | &#32;como pré-processador CSS. Tentei implementar RSCSS & ITCSS como metodologias.
                        | &#32;Além da combinação&#32;
                        span.arquivo-code Jeet + Nib + Rupture
                        | &#32;como grid system, mixins para&#32;
                        span.arquivo-code Stylus
                        | &#32;e media queries, respectivamente.

                li
                    span.arquivo-code tasks

                    p
                        | Meu bebê do s2! Nessa pasta possui um&#32;
                        span.arquivo-code arquivo.js
                        | &#32;para cada tarefa do&#32;
                        span.arquivo-code Gulp
                        | .

                    p
                        | No decorrer desse artigo irei entrar em mais detalhes de como modularizei as tarefas do&#32;
                        span.arquivo-code Gulp
                        | &#32;.

    div.sub-description.heading.cf
        h3.sub-description RSCSS e ITCSS? Why??

        p.text
            | Sempre busco formas de padronizar minhas declarações CSS e uma arquitetura boa, de fácil manutenção. Li um pouco sobre&#32;
            span.arquivo-code BEM
            | &#32;, porém não gostei. Achei a nomenclatura das classes sugerida muito extensa e em determinados projetos completos poderia ser confuso para manutenção. Visto isso, encontrei dois artigos do&#32;
            a.link(href='https://twitter.com/willian_justen', target='_blank') Willian Justen
            | &#32;sobre ambas as metodologias,&#32;
            a.link(href='http://willianjusten.com.br/falando-sobre-rscss/', target='_blank') RSCSS
            | &#32;e&#32;
            a.link(href='http://willianjusten.com.br/organizando-seu-css-com-itcss/', target='_blank') ITCSS
            | .

        p.text Ele explicou com uma didática tão leve que foi de longe um dos melhores artigos sobre arquiteturas CSS. Já tinha optado por ITCSS em outras leituras, porém esse artigo em específico concretizei minha decisão.

        p.text Aqui, não irei entrar em detalhes de como funciona o ITCSS ou RSCSS. Para isso, passa lá no link do artigo que o Willian Justen compartilhou conosco, que praticamente é uma documentação em pt-BR! =)

        p.text
            | Digamos que você vá desenvolver um projeto complexo, de um portal para uma grande empresa/agência, um portal estático ou dinâmico, por exemplo, que irá ter 20 páginas ou mais. No momento em que formos definir a arquitetura CSS para o desenvolvimento vai começar a complicar. Visto isso, o&#32;
            span.arquivo-code ITCSS
            | &#32;surgiu, para organizar nosso CSS de forma escalável e de fácil manutenção.

        p.text.dialog Beleza, tio! Definimos a arquitetura. Mas e como iremos nomear as classes? Que tipo de padrão podemos utilizar pra isso?

        p.text
            | Entra em cena o&#32;
            span.arquivo-code RSCSS
            | &#32;!!!!

        p.text Quanto maior o projeto, maior vai ser o número de linhas de declarações CSS. E, acredite, se não houver um padrão, VAI DAR BO! Quem nunca se perguntou pra que classe X ou Y serve, pra que repetiu Z ou A, etc, etc.

        p.text
            | Nisso, o&#32;
            span.arquivo-code RSCSS
            | &#32;nos dá ideias claras de como nomear classes sem medo de nos perdemos futuramente. Facilitando assim que o processo de desenvolvimento do nosso CSS seja rentável para qualquer projeto front-end.

        p.text Juntar as duas metodologias foi praticamente um casamento perfeito! Parece que as duas são feitas uma para a outra! =D

        p.text
            | Mais um ponto a favor do&#32;
            span.arquivo-code RSCSS
            | &#32;é que podemos utilizar essa metodologia junto com&#32;
            span.arquivo-code Atomic Design
            | . Já temos um padrão de atoms, molecules e organisms nas classes, porém podemos facilmente integrar as duas metodologias. E, podemos ir além, não parar nos atoms.

        p.text
            | Baseando-se nas aulas do curso&#32;
            a.link(href='https://github.com/Webschool-io/be-mean-instagram', target='_blank') Be MEAN
            | &#32;do&#32;
            a.link(href='https://twitter.com/osuissa', target='_blank') Suissa
            | , onde ele nos ensina a utilizar Quarks, Hadrons, etc no back-end.&#32;
            a.link(href='https://github.com/Webschool-io/Node-Atomic-Design-Modelo-Padrao', target='_blank') Física louca
            | , sem dó, porém, muito efetiva. E sim, podemos basearmos nisso e utilizar em nosso front-end!

    div.sub-description.heading
        h3.sub-description E aquela pastinha _includes ali, pra que serve?

        p.text
            | No&#32;
            span.arquivo-code Pug (Jade)
            | &#32;podemos utilizar includes. Digamos que você tenha um projeto web complexo, com front e back-end. No front-end, 90% das páginas irão utilizar o mesmo menu, mesmo header, mesmo footer. Apenas o conteúdo de cada página irá mudar. Pra que repetir esse código em todas as páginas ou porque não usar&#32;
            span.arquivo-code extend template
            span.arquivo-code &#32;block content
            | ?

        p.text Simples, tornando a integração do back-end mais fácil, sem complicações, dinâmico. Com um simples include, podemos trabalhar no back-end para trocar o include X de poucas linhas em certos eventos. Já o extend teria um bloco maior, com mais linhas. O carregamento seria um pouco mais demorado que o include, mesmo não sendo notado a olho nú, mas seria.

        p.text
            |Visando a performance, fácil integração com back-end e fácil manutenção, a escolha para projetos complexos é ir de&#32;
            span.arquivo-code include
            | . Uma escolha pessoal, não é regra, não é padrão!

    div.sub-description.heading
        h3.sub-description Gulp, deixando-o mais bonitinho ainda =)

        p.text
            | A justificava para modularizar as tarefas&#32;
            span.arquivo-code Gulp
            | &#32;foi simples:

        p.text.dialog Se eu posso componetizar/modularizar meu CSS; com aplicações AngularJS; com aplicações PHP (MVC); com aplicações NodeJS s2; porque não posso fazer isso com as minhas tarefas do Gulp?

        p.text Você, dev front-end que conhece e trabalha com Gulp, quantas vezes você parou pra pensar:
            span.dialog &#32;Poxa meu, quantas linhas eu não tenho em um simples gulpfile.js? Já passaram 110 linhas, que saco! Como posso melhorar isso? Não posso modularizar/componetizar igual fazemos com CSS?

        p.text Fiquei extremamente estressado em ver aquele horror. Então, mais noites com poucas horas de sono se foram, rsrs'.

        p.text Encontrei inúmeros tutoriais a respeito, porém a maioria utilizava o Browserify ou Webpack. Lendo um pouco sobre cada um deles, acabei chegando a conclusão de que eles são indicados para projetos mais complexos. Um site, portal de notícias, portfolio, hotsite não vi necessidade de implementá-los. Seria um desperdício de tecnologia!

        p.text
            | Depois de tantas pesquisas, conheci a dependência&#32;
            a.link(href='https://www.npmjs.com/package/gulp-load-plugins', target='_blank') gulp-load-plugins
            | &#32;encontrando no blog da editora&#32;
            a.link(href='https://www.packtpub.com/books/content/blogs', target='_blank') Packt Publishing
            | &#32;um EXCELENTE artigo escrito por Brian Hough: &#32;
            a.dialog.link(href='https://www.packtpub.com/books/content/how-to-simplify-your-development-workflow-with-gulp', target='_blank') How to Simplify Your Development Workflow with Gulp
            | &#32;.

        p.text
            | Após todas as tarefas em arquivos separados, Gulp modularizado, belezinha, o arquivo&#32;
            span.arquivo-code gulpfile.js
            | &#32;ficou dessa forma:

        img(src='img/gulpfile-final.png')

        p.text
            | Com essa dependência, conseguimos criar um&#32;
            span.arquivo-code arquivo.js
            | &#32;para cada tarefa e no&#32;
            span.arquivo-code gulpfile.js
            | &#32;chamar cada tarefa utilizando o&#32;
            span.arquivo-code require
            | .

        p.text
            | Enquanto isso, consumimos o&#32;
            span.arquivo-code config.json
            | &#32;com os caminhos dos diretórios de cada CSS, Imagem, JS, HTML, seja do ambiente de desenvolvimento (source) ou o destino (_public).

        p.text
            | Abaixo, você visualiza exemplo de duas tarefas, o&#32;
            span.arquivo-code browser-sync.js
            | &#32;e&#32;
            span.arquivo-code stylus.js
            | , onde utilizar um simples&#32;
            span.arquivo-code module.exports
            | &#32; para exportamos uma função que já recebe como parâmetro, o próprio&#32;
            span.arquivo-code gulp
            | &#32;além do&#32;
            span.arquivo-code config.json
            | &#32; e a dependência responsável por carregar todas as demais dependências do&#32;
            span.arquivo-code Gulp (plugins)
            | .

        img(src='img/browser-sync-stylus.png')

        p.text
            | Trabalhando dessa forma, caso surga alguma nova dependência e por consequência uma nova tarefa, basta criarmos um arquivo novo, chamarmos com o require e incluirmos nas demais tarefas, caso seja necessário. Fácil manutenção, fácil atualização, fácil integração!

    div.sub-description.heading
        h3.sub-description Concluindo..

        p.text Que artigo longo, rapaz! rs'

        p.text A minha ideia aqui foi compartilhar um pouco de um workflow simples, porém eficiente atende às minhas necessidades atuais em front-end. Sei que tenho muito a melhorar, adicionar mais algumas coisinhas pra melhorar ainda mais esse workflow. Mas por enquanto, atende às minhas necessidades muito bem.

        p.text
            | Ainda é um dos primeiros artigos que escrevo, então sorry se não me expressei tão bem em alguns pontos. Se alguém quiser utilizar, fique a vontade, o código está todo em meu&#32;
            a.link(href='https://github.com/ednilsonamaral/workflow', target='_blank') GitHub
            | . Peço apenas que dê os devidos créditos! =p

        p.text
            | Caso tenha alguma dúvida, sugestão, reclamação, please, entre em contato comigo, através de um simples comentário ou criando uma issue nesse&#32;
            a.link(href='https://github.com/ednilsonamaral/workflow', target='_blank') repositório
            | . Se gostou ou não, compartilhe com seus amigos front-end! =p

        p.text É isso aí pessoal, vaaleu, até mais! =D

    div.sub-description.heading
        h3.sub-description Referências

        ul
            li
                a.link(href='http://willianjusten.com.br/falando-sobre-rscss/', target='_blank') Falando sobre RSCSS
            li
                a.link(href='http://willianjusten.com.br/organizando-seu-css-com-itcss/', target='_blank') Organizando seu CSS com ITCSS
            li
                a.link(href='https://www.xfive.co/blog/itcss-scalable-maintainable-css-architecture/', target='_blank') ITCSS: SCALABLE AND MAINTAINABLE CSS ARCHITECTURE
            li
                a.link(href='http://www.creativebloq.com/web-design/manage-large-css-projects-itcss-101517528', target='_blank') Manage large CSS projects with ITCSS
            li
                a.link(href='http://lucasmaiaesilva.com.br/grids-sem%C3%A2nticos-com-jeet/', target='_blank') Grids Semânticos com Jeet
            li
                a.link(href='http://codepen.io/suissa/pen/RNWeaE', target='_blank') Jeet 5 - Mobile First (Stylus)
            li
                a.link(href='https://www.packtpub.com/books/content/how-to-simplify-your-development-workflow-with-gulp', target='_blank') How to Simplify Your Development Workflow with Gulp
            li
                a.link(href='https://davidwalsh.name/stylus-rem', target='_blank') Stylus PX to REM Mixin
